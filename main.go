package main

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"os"

	"github.com/gorilla/mux"
	log "github.com/sirupsen/logrus"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var (
	ctx          = context.Background()
	kmsProviders map[string]map[string]interface{}
	client       *mongo.Client
)

func main() {
	// initial setup
	kmsProviders = map[string]map[string]interface{}{
		"aws": {
			"accessKeyId":     os.Getenv("AWS_KID"),
			"secretAccessKey": os.Getenv("AWS_SAK"),
		},
	}

	createDataKey()
	client = createEncryptedClient()
	defer client.Disconnect(ctx)

	//#coll := client.Database("foo").Collection("bar")
	//#_ = coll.Drop(ctx)

	// insert a document with an encrypted field and a plaintext field
	// _, err := coll.InsertOne(ctx, bson.M{
	//      "plaintext": "hello world",
	//      "ssn":       "123-45-6789",
	//      "altname":   "altname",
	// })

	// find and print the inserted document
	//res, _ := coll.FindOne(ctx, bson.D{}).DecodeBytes()
	//fmt.Println(res)

	// new stuff
	router := mux.NewRouter().StrictSlash(true)

	// CRUD
	// foo is the encrypted docs
	router.HandleFunc("/foo", createhandler).Methods("POST")
	router.HandleFunc("/foo/{id}", readhandler).Methods("GET")

	// bar is unencrypted docs
	router.HandleFunc("/bar", createhandler).Methods("POST")
	router.HandleFunc("/bar/{id}", readhandler).Methods("GET")

	listenOn := ":8888" //options.Address +
	if err := http.ListenAndServe(listenOn, router); err != nil {
		panic(err)
	}
}

// create a new data key with an alternate key name
func createDataKey() {
	// create key vault client and drop key vault collection
	kvClient, err := mongo.Connect(ctx, options.Client().ApplyURI(os.Getenv("MDB_URI")))
	if err != nil {
		log.Fatalf("Connect error for key vault client: %v", err)
	}
	_ = kvClient.Database("keyvault").Collection("__datakeys").Drop(ctx)

	// create ClientEncryption
	clientEncOpts := options.ClientEncryption().SetKeyVaultNamespace("keyvault.__datakeys").SetKmsProviders(kmsProviders)
	clientEnc, err := mongo.NewClientEncryption(kvClient, clientEncOpts)

	defer clientEnc.Close(ctx)

	// create a new data key
	dataKeyOpts := options.DataKey().SetKeyAltNames([]string{"altname"})
	_, err = clientEnc.CreateDataKey(ctx, "aws", dataKeyOpts)

}

// create a client configured with auto encryption that uses the key generated by createDataKey
func createEncryptedClient() *mongo.Client {
	// create a client with auto encryption
	schemaMap := map[string]interface{}{
		"tutorial.foo": readJSONFile("collection_schema.json"),
	}
	autoEncOpts := options.AutoEncryption().
		SetKeyVaultNamespace("keyvault.__datakeys").
		SetKmsProviders(kmsProviders).
		SetSchemaMap(schemaMap)

	clientOpts := options.Client().ApplyURI(os.Getenv("MDB_URI")).SetAutoEncryptionOptions(autoEncOpts)
	autoEncryptionClient, err := mongo.Connect(ctx, clientOpts)
	if err != nil {
		log.Fatalf("Connect error for client with automatic encryption: %v", err)
	}
	return autoEncryptionClient
}

func readJSONFile(file string) bson.D {
	content, err := ioutil.ReadFile(file)
	if err != nil {
		log.Fatalf("ReadFile error for %v: %v", file, err)
	}

	var fileDoc bson.D
	if err = bson.UnmarshalExtJSON(content, false, &fileDoc); err != nil {
		log.Fatalf("UnmarshalExtJSON error for file %v: %v", file, err)
	}
	return fileDoc
}

// HTTP Handlers CRUD+ For Account

func createhandler(w http.ResponseWriter, r *http.Request) {
	defer func() {
		if r != nil {
			r.Body.Close()
		}
	}()

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("body - ", err.Error())
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	var doc map[string]string
	err = json.Unmarshal(body, &doc)
	if err != nil {
		log.Error("unmarshal - ", err.Error())
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// database
	client := createEncryptedClient()
	defer client.Disconnect(ctx)

	coll := client.Database("foo").Collection("bar")
	_ = coll.Drop(ctx)

	// insert a document with an encrypted field and a plaintext field
	result, err := coll.InsertOne(ctx, bson.M{
		"plaintext": "hello world",
		"ssn":       "123-45-6789",
		"altname":   "altname",
	})

	// success response
	w.Header().Set("Content-Type", "application/json;charset=UTF-8")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(result)
}

//readhandler is
func readhandler(w http.ResponseWriter, r *http.Request) {
	defer func() {
		if r != nil {
			r.Body.Close()
		}
	}()

	params := mux.Vars(r)
	ID, ok := params["id"]
	if !ok {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	// result, err := read(ID)

	// database
	client := createEncryptedClient()
	defer client.Disconnect(ctx)

	coll := client.Database("foo").Collection("bar")
	_ = coll.Drop(ctx)

	// insert a document with an encrypted field and a plaintext field
	result, err := coll.Find(ctx, bson.M{
		"plaintext": ID,
	})

	if err != nil {
		log.Error("atlas - \n", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	// success response
	w.Header().Set("Content-Type", "application/json;charset=UTF-8")
	json.NewEncoder(w).Encode(result)
}
